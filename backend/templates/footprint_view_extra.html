<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Footprint Chart</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
</head>

<body class="bg-gray-100 flex flex-col h-screen">
    <!-- Top Toolbar -->
    <div class="bg-white shadow-md p-4 z-10">
        <div class="container mx-auto flex flex-wrap items-center justify-between gap-4">
            <h1 class="text-2xl font-bold text-gray-800">Footprint Chart</h1>

            <div class="flex items-center gap-4 flex-1 justify-end">
                <!-- Instrument Select -->
                <div class="flex items-center gap-2">
                    <label for="instrument-select" class="font-semibold text-gray-600">Instrument:</label>
                    <select id="instrument-select" class="p-2 border rounded-md min-w-[200px]"></select>
                </div>

                <!-- Replay Controls -->
                <div class="flex items-center gap-2 bg-gray-50 p-2 rounded-lg border">
                    <div class="flex flex-col gap-1">
                        <label class="text-xs font-semibold text-gray-600">Replay Start:</label>
                        <input type="range" id="replay-range" min="0" max="100" value="0"
                            class="w-32 h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-600">
                    </div>
                    <span id="replay-time-display" class="text-xs text-gray-500 w-20">--:--</span>

                    <div class="h-8 w-px bg-gray-300 mx-2"></div>

                    <label for="replay-speed-select" class="font-semibold text-gray-600 text-sm">Speed:</label>
                    <select id="replay-speed-select" class="p-1 border rounded-md text-sm">
                        <option value="0">No Delay</option>
                        <option value="10">10ms</option>
                        <option value="20">20ms</option>
                        <option value="50">50ms</option>
                        <option value="100">100ms</option>
                        <option value="1000">1s</option>
                        <option value="10000">10s</option>
                    </select>
                    <button id="replay-button"
                        class="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded-md font-medium text-sm transition-colors">
                        Replay
                    </button>
                    <button id="stop-replay-button"
                        class="bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded-md font-medium text-sm transition-colors hidden">
                        Stop
                    </button>
                </div>

                <!-- OI Data Display (Compact) -->
                <div id="oi-data" class="flex gap-4 text-sm bg-gray-50 p-2 rounded border">
                    <span class="text-gray-500">OI Data: Loading...</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 overflow-hidden p-4">
        <div class="container mx-auto h-full flex flex-col gap-4">
            <!-- Footprint Chart -->
            <div id="chart" class="w-full flex-1 bg-white rounded-lg shadow-md min-h-[400px]"></div>

            <!-- CVD Chart -->
            <div id="cvd-chart" class="w-full h-48 bg-white rounded-lg shadow-md shrink-0"></div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const chart = echarts.init(document.getElementById('chart'));
            const cvdChart = echarts.init(document.getElementById('cvd-chart'));
            const oiDataElement = document.getElementById('oi-data');
            const instrumentSelect = document.getElementById('instrument-select');
            const replayButton = document.getElementById('replay-button');
            const stopReplayButton = document.getElementById('stop-replay-button');
            const replayRange = document.getElementById('replay-range');
            const replayTimeDisplay = document.getElementById('replay-time-display');

            const socket = io();

            let footprintData = [];
            let cvdData = [];
            let currentCvd = 0;
            let barStartCvd = 0;
            let invertCvd = false;

            let replayStartTs = 0;
            let replayEndTs = 0;

            // Render Scheduling
            let mainDirty = false;
            let cvdDirty = false;
            let lastMainRender = 0;
            let lastCvdRender = 0;

            // Add Invert Toggle to UI
            const controlsDiv = document.querySelector('.flex.items-center.gap-2:nth-child(2)'); // Replay controls div
            const invertLabel = document.createElement('label');
            invertLabel.className = "flex items-center gap-1 text-sm font-semibold text-gray-600 ml-4 cursor-pointer";
            invertLabel.innerHTML = `<input type="checkbox" id="invert-cvd" class="form-checkbox h-4 w-4 text-blue-600"> Invert CVD`;
            controlsDiv.appendChild(invertLabel);

            document.getElementById('invert-cvd').addEventListener('change', (e) => {
                invertCvd = e.target.checked;
                // Re-calculate CVD from scratch
                recalcCvd();
            });

            // Resize charts on window resize
            window.addEventListener('resize', () => {
                chart.resize();
                cvdChart.resize();
            });

            // Throttle function (Removed - using Render Loop instead)
            // function throttle(func, limit) { ... }
            // const throttledRenderCvd = throttle(...)

            // Sync Logic: Manual handlers to ensure Slider works
            let isSyncing = false;

            chart.on('dataZoom', function (params) {
                if (isSyncing) return;
                isSyncing = true;

                // Params can be a single object or a batch array
                const batch = params.batch ? params.batch[0] : params;

                // Avoid infinite loop: check if the event was triggered by 'dataZoom' action from code
                // ECharts doesn't provide a clean 'source' flag, but usually internal dispatch doesn't carry 'batch'
                // exactly the same way or we can check simple flag if we need to.
                // However, dispatchAction DOES NOT trigger 'dataZoom' event by default unless specified.
                // So reliable way is straightforward dispatch.

                cvdChart.dispatchAction({
                    type: 'dataZoom',
                    start: batch.start,
                    end: batch.end,
                    startValue: batch.startValue,
                    endValue: batch.endValue
                });

                isSyncing = false;
            });

            cvdChart.on('dataZoom', function (params) {
                if (isSyncing) return;
                isSyncing = true;

                const batch = params.batch ? params.batch[0] : params;
                chart.dispatchAction({
                    type: 'dataZoom',
                    start: batch.start,
                    end: batch.end,
                    startValue: batch.startValue,
                    endValue: batch.endValue
                });

                isSyncing = false;
            });


            function renderCvdChart(data) {
                const options = {
                    animation: false,
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: { type: 'cross', sync: { group: 'group1' } }
                    },
                    grid: {
                        left: '50',
                        right: '20',
                        top: '10',
                        bottom: '20',
                        containLabel: false
                    },
                    xAxis: {
                        type: 'category',
                        data: data.map(item => new Date(item.ts).toLocaleTimeString()),
                        boundaryGap: true,
                        axisLabel: { show: false },
                        axisTick: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        scale: true,
                        splitLine: { show: false }
                    },
                    dataZoom: [
                        { type: 'inside', xAxisIndex: [0] },
                    ],
                    series: [
                        {
                            name: 'CVD',
                            type: 'candlestick',
                            data: data.map(item => [item.open, item.close, item.low, item.high]),
                            itemStyle: {
                                color: '#ef4444',
                                color0: '#22c55e',
                                borderColor: '#ef4444',
                                borderColor0: '#22c55e'
                            }
                        }
                    ]
                };

                cvdChart.setOption(options);
            }

            function recalcCvd() {
                cvdData = [];
                currentCvd = 0;
                barStartCvd = 0;

                footprintData.forEach(bar => {
                    updateCvdData(bar, false);
                });
                renderCvdChart(cvdData);
            }

            function updateCvdData(newData, shouldRender = true) {
                const { ts, footprint } = newData;
                const buyVolume = Object.values(footprint).reduce((total, a) => total + a.buy, 0);
                const sellVolume = Object.values(footprint).reduce((total, a) => total + a.sell, 0);

                let barDelta = buyVolume - sellVolume;
                if (invertCvd) {
                    barDelta = -barDelta;
                }

                const lastBar = cvdData.length > 0 ? cvdData[cvdData.length - 1] : null;

                if (lastBar && lastBar.ts === ts) {
                    const currentTotalCvd = barStartCvd + barDelta;
                    lastBar.close = currentTotalCvd;
                    lastBar.high = Math.max(lastBar.high, currentTotalCvd);
                    lastBar.low = Math.min(lastBar.low, currentTotalCvd);
                    currentCvd = currentTotalCvd;
                } else {
                    if (lastBar) {
                        barStartCvd = lastBar.close;
                    } else {
                        barStartCvd = 0;
                    }
                    const currentTotalCvd = barStartCvd + barDelta;
                    cvdData.push({
                        ts: ts,
                        open: barStartCvd,
                        high: Math.max(barStartCvd, currentTotalCvd),
                        low: Math.min(barStartCvd, currentTotalCvd),
                        close: currentTotalCvd
                    });
                    currentCvd = currentTotalCvd;
                }

                if (shouldRender) {
                    cvdDirty = true;
                }
            }

            function renderChart(data) {
                const options = {
                    animation: false,
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: { type: 'cross' },
                        formatter: function (params) {
                            const item = data[params[0].dataIndex];
                            if (!item) return '';
                            return `
                                <b>${new Date(item.ts).toLocaleTimeString()}</b><br/>
                                O: ${item.open} H: ${item.high} L: ${item.low} C: ${item.close}<br/>
                                Vol: ${item.volume}
                            `;
                        }
                    },
                    grid: {
                        left: '50',
                        right: '20',
                        top: '20',
                        bottom: '20',
                        containLabel: false
                    },
                    xAxis: {
                        type: 'category',
                        data: data.map(item => new Date(item.ts).toLocaleTimeString()),
                        boundaryGap: true,
                        axisLine: { show: false },
                        axisTick: { show: false }
                    },
                    yAxis: {
                        type: 'value',
                        scale: true,
                        splitLine: { lineStyle: { color: '#eee' } }
                    },
                    dataZoom: [
                        { type: 'inside', xAxisIndex: [0] },
                        { type: 'slider', show: true, bottom: 0, xAxisIndex: [0] }
                    ],
                    series: [
                        {
                            name: 'Footprint',
                            type: 'custom',
                            renderItem: function (params, api) {
                                const index = params.dataIndex;
                                const item = data[index];
                                if (!item) return;

                                const categoryIndex = api.value(0);
                                const openPt = api.coord([categoryIndex, item.open]);
                                const closePt = api.coord([categoryIndex, item.close]);
                                const highPt = api.coord([categoryIndex, item.high]);
                                const lowPt = api.coord([categoryIndex, item.low]);

                                const barWidth = api.size([0, 0])[0] * 0.9;
                                const halfWidth = barWidth / 2;
                                const xCenter = openPt[0];

                                const isBullish = item.close >= item.open;
                                const candleColor = isBullish ? '#22c55e' : '#ef4444';

                                const children = [];

                                // Wick
                                children.push({
                                    type: 'line',
                                    shape: {
                                        x1: highPt[0], y1: highPt[1],
                                        x2: lowPt[0], y2: lowPt[1]
                                    },
                                    style: { stroke: candleColor, lineWidth: 1 }
                                });

                                let maxVol = 0;
                                Object.values(item.footprint).forEach(v => {
                                    maxVol = Math.max(maxVol, v.buy, v.sell);
                                });
                                if (maxVol === 0) maxVol = 1;

                                const priceLevels = Object.keys(item.footprint).sort((a, b) => parseFloat(b) - parseFloat(a));

                                priceLevels.forEach(price => {
                                    const p = parseFloat(price);
                                    const vol = item.footprint[price];
                                    const pt = api.coord([categoryIndex, p]);
                                    const rowHeight = 14;

                                    const sellWidth = (vol.sell / maxVol) * halfWidth;
                                    children.push({
                                        type: 'rect',
                                        shape: {
                                            x: xCenter - sellWidth,
                                            y: pt[1] - rowHeight / 2,
                                            width: sellWidth,
                                            height: rowHeight
                                        },
                                        style: { fill: '#93c5fd' }
                                    });

                                    const buyWidth = (vol.buy / maxVol) * halfWidth;
                                    children.push({
                                        type: 'rect',
                                        shape: {
                                            x: xCenter,
                                            y: pt[1] - rowHeight / 2,
                                            width: buyWidth,
                                            height: rowHeight
                                        },
                                        style: { fill: '#86efac' }
                                    });

                                    if (vol.sell > 0) {
                                        children.push({
                                            type: 'text',
                                            style: {
                                                text: vol.sell.toString(),
                                                x: xCenter - 2,
                                                y: pt[1],
                                                textAlign: 'right',
                                                textVerticalAlign: 'middle',
                                                fontSize: 10,
                                                fill: '#000'
                                            }
                                        });
                                    }

                                    if (vol.buy > 0) {
                                        children.push({
                                            type: 'text',
                                            style: {
                                                text: vol.buy.toString(),
                                                x: xCenter + 2,
                                                y: pt[1],
                                                textAlign: 'left',
                                                textVerticalAlign: 'middle',
                                                fontSize: 10,
                                                fill: '#000'
                                            }
                                        });
                                    }

                                    children.push({
                                        type: 'line',
                                        shape: {
                                            x1: xCenter, y1: pt[1] - rowHeight / 2,
                                            x2: xCenter, y2: pt[1] + rowHeight / 2
                                        },
                                        style: { stroke: '#ccc', lineWidth: 1 }
                                    });
                                });

                                return {
                                    type: 'group',
                                    children: children
                                };
                            },
                            data: data.map((item, index) => [index, item.close])
                        }
                    ]
                };
                chart.setOption(options);
            }

            function updateFootprintData(newData) {
                const { ts } = newData;
                const lastBar = footprintData.length > 0 ? footprintData[footprintData.length - 1] : null;

                if (lastBar && lastBar.ts === ts) {
                    footprintData[footprintData.length - 1] = newData;
                } else {
                    footprintData.push(newData);
                }
                mainDirty = true;
            }

            // --- Render Loop (10 FPS) ---
            setInterval(() => {
                if (mainDirty) {
                    renderChart(footprintData);
                    mainDirty = false;
                }
                if (cvdDirty) {
                    renderCvdChart(cvdData);
                    cvdDirty = false;
                }
            }, 100);

            socket.on('connect', () => {
                console.log('Connected to WebSocket');
            });

            socket.on('footprint_data', (data) => {
                updateFootprintData(data);
                updateCvdData(data);
            });

            socket.on('footprint_update', (data) => {
                updateFootprintData(data);
                updateCvdData(data);
            });

            socket.on('oi_update', (data) => {
                oiDataElement.innerHTML = `
                    <div class="flex flex-col">
                        <span class="font-bold">OI: ${data.open_interest}</span>
                        <span class="text-xs text-gray-500">Change: ${data.oi_change}</span>
                    </div>
                `;
            });

            fetch('/api/instruments')
                .then(response => response.json())
                .then(instruments => {
                    instruments.forEach(inst => {
                        const option = document.createElement('option');
                        option.value = inst.key;
                        option.textContent = inst.name;
                        instrumentSelect.appendChild(option);
                    });
                    if (instruments.length > 0) {
                        fetchReplayRange(instruments[0].key);
                        fetchOIData(instruments[0].key);
                    }
                });

            function fetchOIData(instrument) {
                oiDataElement.innerHTML = '<span class="text-gray-500">Loading OI...</span>';
                fetch(`/api/oi_data/${instrument}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            oiDataElement.innerHTML = `<span class="text-red-500 text-xs">${data.error}</span>`;
                        } else {
                            oiDataElement.innerHTML = `
                                <div class="flex flex-col">
                                    <span class="font-bold">OI: ${data.open_interest}</span>
                                    <span class="text-xs text-gray-500">Change: ${data.oi_change}</span>
                                </div>
                            `;
                        }
                    })
                    .catch(err => {
                        oiDataElement.innerHTML = `<span class="text-gray-400 text-xs">No OI Data</span>`;
                    });
            }

            function fetchReplayRange(instrument) {
                fetch(`/api/replay_range/${instrument}`)
                    .then(r => r.json())
                    .then(data => {
                        if (!data.error) {
                            replayStartTs = data.start_ts;
                            replayEndTs = data.end_ts;

                            // Configure Slider
                            // Slider will represent 0 to 100% of the range
                            replayRange.value = 0;
                            updateReplayTimeDisplay(0);
                        }
                    });
            }

            function updateReplayTimeDisplay(percent) {
                if (!replayStartTs || !replayEndTs) return;
                const duration = replayEndTs - replayStartTs;
                const currentTs = replayStartTs + (duration * (percent / 100));

                const date = new Date(currentTs);
                replayTimeDisplay.textContent = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }

            replayRange.addEventListener('input', (e) => {
                updateReplayTimeDisplay(e.target.value);
            });

            instrumentSelect.addEventListener('change', (event) => {
                const selectedInstrument = event.target.value;
                socket.emit('change_security', selectedInstrument);
                fetchOIData(selectedInstrument);
                fetchReplayRange(selectedInstrument);
            });

            replayButton.addEventListener('click', () => {
                const selectedInstrument = instrumentSelect.value;
                const replaySpeed = document.getElementById('replay-speed-select').value;

                // Calculate start time based on slider
                const percent = replayRange.value;
                const duration = replayEndTs - replayStartTs;
                const startTs = Math.floor(replayStartTs + (duration * (percent / 100)));

                // Reset State completely
                footprintData = [];
                cvdData = [];
                currentCvd = 0;
                barStartCvd = 0;

                // Clear charts
                renderChart([]);
                renderCvdChart([]);

                replayButton.disabled = true;
                stopReplayButton.classList.remove('hidden');

                socket.emit('replay_market_data', {
                    instrument_key: selectedInstrument,
                    speed: replaySpeed,
                    start_ts: startTs
                });

                // Reset Stop Button state just in case
                stopReplayButton.disabled = false;
                stopReplayButton.textContent = "Stop";
            });

            socket.on('replay_finished', (data) => {
                console.log("Replay finished:", data.reason);
                replayButton.disabled = false;
                replayButton.textContent = "Replay";
                stopReplayButton.classList.add('hidden');
                replayButton.classList.remove('hidden');
            });

            stopReplayButton.addEventListener('click', () => {
                socket.emit('stop_replay');
                // Button state will be handled by replay_finished event,
                // but we can disable this button to prevent double clicks
                stopReplayButton.disabled = true;
                stopReplayButton.textContent = "Stopping...";
            });
        });
    </script>
</body>

</html>