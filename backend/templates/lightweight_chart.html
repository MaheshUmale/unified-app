<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightweight Chart - {{ instrument_key }}</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }

        #chart-container {
            width: 100%;
            height: 100vh;
        }

        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }

        .status {
            color: #0ECB81;
        }
    </style>
</head>

<body>
    <div id="stats">
        <div><strong>{{ instrument_name }}</strong></div>
        <div id="price-info">Price: -- | Vol: --</div>
        <div id="time-info">Time: --</div>
        <div class="status" id="connection-status">Connecting...</div>
    </div>
    <div id="chart-container"></div>

    <script>
        const INSTRUMENT_KEY = "{{ instrument_key }}";
        const API_BASE_URL = "http://localhost:5080";
        const socket = io();

        let tradingChart = echarts.init(document.getElementById('chart-container'), 'dark');

        let chartData = {
            timestamps: [],      // Localized time string (ECharts X-Axis labels)
            rawTimestamps: [],   // Raw Unix timestamp in milliseconds (for robust lookup)
            candlesticks: [],
            buyVolume: [],
            sellVolume: []
        };

        let tradeSignalsByTradeId = {};
        let chartMarkers = [];
        let historyLoaded = false; // Flag to ensure markers are processed after history

        // Chart configuration base (unchanged)
        const baseOption = {
            backgroundColor: '#1a1a1a',
            grid: [
                { left: '5%', right: '5%', top: '5%', height: '70%' },
                { left: '5%', right: '5%', top: '80%', height: '15%' }
            ],
            xAxis: [
                { type: 'category', data: [], gridIndex: 0, axisLabel: { color: '#888' } },
                { type: 'category', data: [], gridIndex: 1, axisLabel: { color: '#888' } }
            ],
            yAxis: [
                { scale: true, gridIndex: 0, splitLine: { lineStyle: { color: '#333' } } },
                { gridIndex: 1, splitLine: { lineStyle: { color: '#333' } } }
            ],
            series: [
                {
                    name: 'Candlestick',
                    type: 'candlestick',
                    data: [],
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    itemStyle: {
                        color: '#116343',
                        color0: '#990619',
                        borderColor: '#0ECB81',
                        borderColor0: '#F6465D'
                    },
                    markPoint: {
                        label: { color: '#fff' },
                        data: chartMarkers,
                        symbolSize: 40
                    },
                    markLine: {
                        symbol: 'none',
                        data: []
                    }
                },
                {
                    name: 'Buy Volume',
                    type: 'bar',
                    data: [],
                    xAxisIndex: 1,
                    yAxisIndex: 1,
                    itemStyle: { color: '#0ECB81' }
                },
                {
                    name: 'Sell Volume',
                    type: 'bar',
                    data: [],
                    xAxisIndex: 1,
                    yAxisIndex: 1,
                    itemStyle: { color: '#F6465D' }
                }
            ],
            tooltip: {
                trigger: 'axis',
                axisPointer: { type: 'cross' },
                backgroundColor: 'rgba(0,0,0,0.8)',
                borderColor: '#333',
                textStyle: { color: '#fff' }
            },
              toolbox: {
        feature: {
            dataZoom: {
                // This option enables the "Restore" button
                yAxisIndex: false
            },
            restore: {} // This is the actual restore button
            // ... other features
        }
    },
            dataZoom: [
                {
                    type: 'inside',
                    xAxisIndex: [0, 1],
                    start: 90,
                    end: 100
                },
                {
                    type: 'slider',
                    xAxisIndex: [0, 1],
                    start: 90,
                    end: 100,
                    height: 20,
                    bottom: 10,
                    textStyle: { color: '#fff' },
                    handleStyle: { color: '#0ECB81' }
                }
            ]
        };

        tradingChart.setOption(baseOption);

        // --- FETCH SIGNALS ---
        async function fetchTradeSignals() {
            const url = `/api/trade_signals/${INSTRUMENT_KEY}`;
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const signals = await response.json();

                tradeSignalsByTradeId = signals.reduce((acc, signal) => {
                    const id = signal.trade_id;
                    if (!acc[id]) {
                        acc[id] = [];
                    }
                    acc[id].push(signal);
                    return acc;
                }, {});

                console.log('Fetched and grouped trade signals:', Object.keys(tradeSignalsByTradeId).length, 'trades');

                // If history is already loaded, update markers immediately
                if (historyLoaded) {
                    recalculateChartMarkers();
                    updateChart();
                }

            } catch (e) {
                console.error('Error fetching trade signals:', e);
            }
        }

        fetchTradeSignals();

        // --- SOCKET HANDLERS ---
        socket.on('connect', () => {
            document.getElementById('connection-status').innerText = 'Connected';
            document.getElementById('connection-status').style.color = '#0ECB81';
            socket.emit('subscribe_to_instrument', { instrument_key: INSTRUMENT_KEY });
        });

        socket.on('disconnect', () => {
            document.getElementById('connection-status').innerText = 'Disconnected';
            document.getElementById('connection-status').style.color = '#F6465D';
        });

        socket.on('footprint_history', (bars) => {
            console.log('Received history:', bars.length, 'bars');

            // Process all history bars
            bars.forEach(bar => addBar(bar, { isHistory: true }));

            // Set flag and recalculate markers ONLY after all history is processed
            historyLoaded = true;
            // --- DEBUG: Stored Bar Timestamps ---
    console.log("--- DEBUG: Stored Bar Timestamps ---");
    console.log("Total bars stored:", chartData.rawTimestamps.length);
    if (chartData.rawTimestamps.length > 0) {
        const firstTs = chartData.rawTimestamps[0];
        const lastTs = chartData.rawTimestamps[chartData.rawTimestamps.length - 1];

        console.log("History START:", firstTs, "ISO:", new Date(firstTs).toISOString());
        console.log("History END:", lastTs, "ISO:", new Date(lastTs).toISOString());
    }
    console.log("-------------------------------------");
    // ----------------------------

    recalculateChartMarkers();
    updateChart();

        });

        socket.on('footprint_update', (bar) => {
            addBar(bar);
            if (historyLoaded) {
                recalculateChartMarkers();
                updateChart();
            }
        });

        socket.on('footprint_data', (bar) => {
            addBar(bar);
            if (historyLoaded) {
                recalculateChartMarkers();
                updateChart();
            }
        });

        // --- CORE LOGIC ---

        function addBar(bar, options = {}) {
            let ts = bar.ts;
            if (ts < 1000000000000) ts *= 1000; // Milliseconds

            const timeStr = new Date(ts).toLocaleTimeString();
            const existingIndex = chartData.rawTimestamps.indexOf(ts); // Check by raw timestamp

            const candleData = [bar.open, bar.close, bar.low, bar.high];
            const buyVol = (bar.buy_volume || 0) + (bar.big_buy_volume || 0);
            const sellVol = (bar.sell_volume || 0) + (bar.big_sell_volume || 0);

            if (existingIndex >= 0) {
                // Update existing bar
                chartData.candlesticks[existingIndex] = candleData;
                chartData.buyVolume[existingIndex] = buyVol;
                chartData.sellVolume[existingIndex] = sellVol;
            } else {
                // Find correct insertion position based on raw timestamp
                let insertIndex = chartData.rawTimestamps.length;
                for (let i = 0; i < chartData.rawTimestamps.length; i++) {
                    if (ts < chartData.rawTimestamps[i]) {
                        insertIndex = i;
                        break;
                    }
                }

                // Insert at correct position
                chartData.timestamps.splice(insertIndex, 0, timeStr);
                chartData.rawTimestamps.splice(insertIndex, 0, ts); // <-- Store raw TS
                chartData.candlesticks.splice(insertIndex, 0, candleData);
                chartData.buyVolume.splice(insertIndex, 0, buyVol);
                chartData.sellVolume.splice(insertIndex, 0, sellVol);
            }

            if (!options.isHistory || existingIndex === chartData.rawTimestamps.length - 1) {
                document.getElementById('price-info').innerText = `Price: ${bar.close.toFixed(2)} | Vol: ${bar.volume || 0}`;
                document.getElementById('time-info').innerText = `Time: ${timeStr}`;
            }
        }


function recalculateChartMarkers() {
    if (!historyLoaded) {
        console.log("History not yet loaded. Skipping marker calculation.");
        return;
    }

    // Fixed offset for IST (UTC+5:30) used by Indian market.
    // If the trade signal time is 5.5 hours too late, we subtract 19,800,000 ms.
    const IST_OFFSET_MS = 19800000;
    const barDurationMs = 60000; // Assuming 1-minute bars
    chartMarkers = []; // Clear previous markers

    for (const tradeId in tradeSignalsByTradeId) {
        const signals = tradeSignalsByTradeId[tradeId];

        signals.forEach(signal => {
            const tradeTs = signal.time;
            // Convert to milliseconds if needed
            let tradeTimeMs = tradeTs < 1000000000000 ? tradeTs * 1000 : tradeTs;

            // --- CRITICAL FIX: Adjust trade signal time back by 5.5 hours ---
            // Example: 09:15:00Z (from signal) -> 03:45:00Z (actual bar time)
            const tradeTimeUtcCorrected = tradeTimeMs - IST_OFFSET_MS;

            // Log the corrected time for verification
            console.log(`Searching for trade ${tradeId.substring(0, 4)}. Corrected Time (UTC): ${new Date(tradeTimeUtcCorrected).toISOString()}`);

            // Find the bar index in the chart's raw UTC timestamps
            const barIndex = chartData.rawTimestamps.findIndex(barTs => {
                // Match if: bar_ts (start of bar) <= corrected_trade_ts < bar_ts + barDurationMs (end of bar)
                return tradeTimeUtcCorrected >= barTs && tradeTimeUtcCorrected < barTs + barDurationMs;
            });

            if (barIndex === -1) {
                 console.log(`Marker NOT FOUND for trade ${tradeId.substring(0, 4)}. Time: ${new Date(tradeTimeMs).toISOString()}.`);
                 return; // Skip marker creation if bar not found
            }

            // --- Marker creation logic starts here (use the found barIndex) ---
            const barTimeStr = chartData.timestamps[barIndex];
            const barData = chartData.candlesticks[barIndex];

            if (barData) {
                const [open, close, low, high] = barData;

                const marker = {
                    coord: [barTimeStr, (signal.type === 'ENTRY' ? low : high)],
                    value: signal.type,
                    itemStyle: {
                        color: signal.type === 'ENTRY' ? '#0ECB81' : '#F6465D'
                    },
                    symbol: 'pin',
                    symbolRotate: signal.type === 'ENTRY' ? 0 : 180,
                    label: {
                        formatter: `${signal.signal} (${tradeId.substring(0, 4)})\n@${signal.price.toFixed(2)}`,
                        position: signal.type === 'ENTRY' ? 'bottom' : 'top'
                    }
                };
                chartMarkers.push(marker);

                const markerSLTP = {
                    coord: [barTimeStr, (signal.type === 'ENTRY' ? signal.sl_price : signal.tp_price)],
                    value: signal.type,
                    itemStyle: {
                        color: signal.type === 'ENTRY' ? '#0ECB81' : '#F6465D'
                    },
                    symbol: 'triangle',
                    symbolSize: 8,
                    symbolRotate: signal.type === 'ENTRY' ? 0 : 180,
                    label: {
                        // text: (signal.type === 'ENTRY' ? signal.sl_price : signal.tp_price),
                        formatter: `${signal.type === 'ENTRY' ? 'SL' : 'TP'}\n@${(signal.type === 'ENTRY' ? signal.sl_price : signal.tp_price).toFixed(2)}`,
                        // position: signal.type === 'ENTRY' ? 'bottom' : 'top'
                    }
                };
                chartMarkers.push(markerSLTP);
            }
        });
    }
}

        function updateChart() {
            // --- DYNAMIC SL LINE LOGIC (Unchanged) ---
            let slLines = [];
            let latestEntryTime = 0;
            let latestSlPrice = null;

            for (const tradeId in tradeSignalsByTradeId) {
                const signals = tradeSignalsByTradeId[tradeId];
                const entry = signals.find(s => s.type === 'ENTRY');
                const exit = signals.find(s => s.type === 'EXIT');

                // Check for open trade or the most recent entry
                if (entry && entry.time > latestEntryTime) {
                    if (!exit || exit.time < entry.time) { // Check if trade is currently open
                         latestEntryTime = entry.time;
                         latestSlPrice = entry.sl_price;
                    } else if (exit && exit.time > latestEntryTime) { // Check if it's the most recent closed trade
                         latestEntryTime = entry.time; // Use entry time for recency check
                         latestSlPrice = entry.sl_price;
                    }
                }
            }

            if (latestSlPrice !== null) {
                slLines.push({
                    yAxis: latestSlPrice,
                    lineStyle: { type: 'dashed', color: '#F6465D', width: 2 },
                    label: { formatter: 'SL: ' + latestSlPrice.toFixed(2), position: 'end' }
                });
            }
            // --- END DYNAMIC SL LINE LOGIC ---

            tradingChart.setOption({
                xAxis: [
                    { data: chartData.timestamps },
                    { data: chartData.timestamps }
                ],
                series: [
                    {
                        data: chartData.candlesticks,
                        markPoint: {
                            data: chartMarkers // Use the recalculated markers
                        },
                        markLine: {
                            data: slLines // Use the calculated SL lines
                        }
                    },
                    { data: chartData.buyVolume },
                    { data: chartData.sellVolume }
                ]
            });
        }

        // Resize handler
        window.addEventListener('resize', () => {
            tradingChart.resize();
        });
    </script>
</body>

</html>