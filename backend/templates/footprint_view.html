<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Footprint Chart</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <style>
        body {
            background-color: #1a1a1a;
            font-family: 'Inter', sans-serif;
        }

        .chart-container {
            height: 80vh;
            min-height: 600px;
        }
    </style>
</head>

<body class="p-4 sm:p-6">

    <div class="max-w-[1600px] mx-auto bg-white shadow-xl rounded-xl overflow-hidden">
        <!-- Header / Controls -->
        <div class="bg-gray-800 text-white p-4 flex flex-wrap items-center justify-between gap-4">
            <div>
                <h1 class="text-xl font-bold flex items-center gap-2">
                    <span class="text-green-400">●</span> Live Footprint
                    <span class="text-sm font-normal text-gray-400 ml-2" id="connection-status">Connecting...</span>
                </h1>
                <p class="text-xs text-gray-400" id="current-instrument">{{ instrument_key }}</p>
            </div>

            <div class="flex items-center gap-3">
                <!-- Replay Controls -->
                <div class="bg-gray-700 rounded-lg p-1 flex items-center gap-2">
                    <button onclick="startLiveMode()"
                        class="bg-green-600 hover:bg-green-500 px-3 py-1 rounded text-sm font-medium animate-pulse">Live</button>
                    <div class="h-4 w-px bg-gray-500 mx-1"></div>
                    <input type="datetime-local" id="replay-start"
                        class="bg-gray-600 text-white px-2 py-1 rounded text-sm w-40">
                    <input type="number" id="replay-speed" class="bg-gray-600 text-white px-2 py-1 rounded w-20 text-sm"
                        placeholder="Speed (ms)" value="100">
                    <select id="timeframe" class="bg-gray-600 text-white px-2 py-1 rounded text-sm">
                        <option value="1">1 Min</option>
                        <option value="5">5 Min</option>
                        <option value="15">15 Min</option>
                        <option value="30">30 Min</option>
                        <option value="60">1 H</option>
                    </select>
                    <button onclick="startReplay()"
                        class="bg-blue-600 hover:bg-blue-500 px-3 py-1 rounded text-sm font-medium">Replay</button>
                    <button onclick="stopReplay()"
                        class="bg-red-600 hover:bg-red-500 px-3 py-1 rounded text-sm font-medium">Stop</button>
                </div>

                <div class="h-6 w-px bg-gray-600 mx-2"></div>

                <!-- Visualization Settings -->
                <div class="flex flex-col">
                    <label class="text-[10px] text-gray-400 uppercase">Min Vol</label>
                    <input type="number" id="min-vol" value="5"
                        class="bg-gray-700 border-none text-white text-xs rounded w-16 px-1">
                </div>
                <div class="flex flex-col">
                    <label class="text-[10px] text-gray-400 uppercase">Big Player</label>
                    <input type="number" id="big-player" value="50"
                        class="bg-gray-700 border-none text-white text-xs rounded w-16 px-1">
                </div>
            </div>

            <a href="/" class="bg-gray-600 hover:bg-gray-500 text-white px-4 py-2 rounded-lg text-sm font-medium">Back
                to Dashboard</a>
        </div>

        <!-- Main Chart -->
        <div id="chart-wrapper" class="relative chart-container w-full bg-white">
            <div id="trading-chart" class="w-full h-full"></div>
            <div id="waiting-message"
                class="absolute inset-0 flex flex-col items-center justify-center bg-white/80 z-10">
                <p class="text-xl font-semibold text-gray-700">Waiting for Data...</p>
                <p class="text-sm text-gray-500 mt-2">Connecting to Live Feed or click <span
                        class="font-bold text-blue-600">Replay</span> to load history.</p>
            </div>
        </div>

        <!-- Metric Footer -->
        <div class="bg-gray-50 border-t p-2 flex justify-between items-center text-xs text-gray-600 font-mono">
            <div id="stats-left">Trades: 0 | Vol: 0</div>
            <div id="stats-right">Last Update: -</div>
        </div>
    </div>

    <script>
        const socket = io({
            transports: ['websocket'],
            upgrade: false
        });
        const INSTRUMENT_KEY = "{{ instrument_key }}";

        let tradingChart = null;
        let chartUpdateBuffer = null;
        let lastChartUpdate = 0;
        const RENDER_INTERVAL = 200;
        window.currentTimeframe = 1; // Default global timeframe

        // Fetch and set calendar restrictions
        async function setCalendarRestrictions() {
            try {
                const response = await fetch(`/api/replay_range/${encodeURIComponent(INSTRUMENT_KEY)}`);
                const data = await response.json();

                if (data.min_date && data.max_date) {
                    const dateInput = document.getElementById('replay-start');
                    dateInput.min = data.min_date;
                    dateInput.max = data.max_date;
                    dateInput.value = data.min_date;
                }
            } catch (error) {
                console.error('Error fetching date range:', error);
            }
        }
        setCalendarRestrictions();

        // Helper to get fresh chart options
        const getChartOption = () => {
            return {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' },
                    formatter: function (params) {
                        let html = params[0].name + '<br/>';
                        let bubbleInfo = [];
                        params.forEach(item => {
                            if (item.seriesType === 'candlestick') {
                                html += `OHLC: O:${item.data[1].toFixed(2)} C:${item.data[2].toFixed(2)}<br/>`;
                            } else if (item.seriesType === 'scatter') {
                                bubbleInfo.push(`<span style="color:${item.color}">●</span> ${item.data[2]}`);
                            }
                        });
                        if (bubbleInfo.length > 0) {
                            html += `Bubbles: ${bubbleInfo.slice(0, 5).join(' ')}${bubbleInfo.length > 5 ? '...' : ''}<br/>`;
                        }
                        return html;
                    }
                },
                legend: {
                    data: ['Price', 'Bubbles', 'Normal Buy', 'Big Buy', 'Normal Sell', 'Big Sell', 'CVD', 'Footprint'],
                    bottom: 0
                },
                grid: [
                    { left: '3%', right: '3%', height: '55%' },
                    { left: '3%', right: '3%', top: '68%', height: '12%' },
                    { left: '3%', right: '3%', top: '82%', height: '12%' }
                ],
                xAxis: [
                    {
                        type: 'category',
                        gridIndex: 0,
                        splitLine: { show: false },
                        axisLabel: {
                            formatter: function (value) {
                                const date = new Date(parseInt(value));
                                return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                            }
                        },
                        data: []
                    },
                    { type: 'category', gridIndex: 1, axisLabel: { show: false }, data: [] },
                    { type: 'category', gridIndex: 2, axisLabel: { show: false }, data: [] },
                    // Hidden value axis for bubbles to allow continuous positioning
                    { type: 'value', gridIndex: 0, show: false, min: -0.5, max: 0.5 }
                ],
                yAxis: [
                    {
                        scale: true,
                        gridIndex: 0,
                        splitLine: { lineStyle: { color: '#eee' } },
                        min: 'dataMin',
                        max: 'dataMax'
                    },
                    { scale: true, gridIndex: 1, splitLine: { show: false } },
                    { scale: true, gridIndex: 2, splitLine: { show: false }, axisLabel: { show: false } }
                ],
                dataZoom: [
                    { type: 'inside', xAxisIndex: [0, 1, 2, 3], zoomOnMouseWheel: 'ctrl' },
                    { type: 'slider', xAxisIndex: [0, 1, 2, 3], bottom: 20, height: 20 }
                ],
                series: [
                    {
                        name: 'Price',
                        type: 'candlestick',
                        data: [],
                        itemStyle: {
                            color: '#0ECB81',
                            color0: '#F6465D',
                            borderColor: '#0ECB81',
                            borderColor0: '#F6465D'
                        }
                    },
                    {
                        name: 'Bubbles',
                        type: 'scatter',
                        xAxisIndex: 3,
                        data: [],
                        symbolSize: function (data) {
                            return Math.max(5, Math.min(50, Math.log(data[2]) * 5));
                        },
                        itemStyle: {
                            color: function (params) {
                                let minVol = parseInt(document.getElementById('min-vol').value) || 5;
                                let qty = params.data[2];
                                let opacity = 0.2; // Base transparency increased (lower value)
                                if (qty > minVol * 10) opacity = 0.6;
                                else if (qty > minVol * 5) opacity = 0.4;
                                return params.data[3] === 'buy' ? `rgba(0, 255, 0, ${opacity})` : `rgba(255, 0, 0, ${opacity})`;
                            },
                            borderColor: function (params) {
                                return params.data[3] === 'buy' ? 'green' : 'red';
                            },
                            borderWidth: 1
                        }
                    },
                    {
                        name: 'Normal Buy', type: 'bar', stack: 'vol', xAxisIndex: 1, yAxisIndex: 1,
                        itemStyle: { color: '#90EE90' }, data: []
                    },
                    {
                        name: 'Big Buy', type: 'bar', stack: 'vol', xAxisIndex: 1, yAxisIndex: 1,
                        itemStyle: { color: '#006400' }, data: []
                    },
                    {
                        name: 'Normal Sell', type: 'bar', stack: 'vol', xAxisIndex: 1, yAxisIndex: 1,
                        itemStyle: { color: '#FFB6C1' }, data: []
                    },
                    {
                        name: 'Big Sell', type: 'bar', stack: 'vol', xAxisIndex: 1, yAxisIndex: 1,
                        itemStyle: { color: '#8B0000' }, data: []
                    },
                    /* COMMENTED OUT FOR PERFORMANCE - CVD Chart
                    {
                        name: 'CVD', type: 'line', xAxisIndex: 2, yAxisIndex: 2,
                        itemStyle: { color: '#FFD700' }, showSymbol: false, data: []
                    },
                    */
                    /* COMMENTED OUT FOR PERFORMANCE - Footprint Heatmap (Most Expensive!)
                    {
                        name: 'Footprint',
                        type: 'custom',
                        renderItem: function (params, api) {
                            const index = api.value(0);
                            let ts = params.data ? params.data.raw_ts : null;
                            // console.log('[FP RENDER] renderItem called. Index:', index, 'TS:', ts, 'ParamsData:', params.data);

                            // Fallback if params.data is missing (ECharts weirdness)
                            if (!ts) {
                                try {
                                    const xData = tradingChart.getOption().xAxis[0].data;
                                    if (xData && xData[index]) {
                                        ts = xData[index];
                                        // console.log('[FP RENDER] Recovered TS:', ts);
                                    }
                                } catch (e) {
                                    console.error('[FP RENDER] Error recovering TS:', e);
                                }
                            }

                            if (!ts) {
                                // console.warn('[FP RENDER] No TS found');
                                return;
                            }

                            const children = [];
                            const candleWidth = api.size([0, 0])[0];
                            const halfWidth = candleWidth / 2.2;
                            const x = api.coord([index, 0])[0];
                            const fpData = window.footprintCache ? window.footprintCache[ts] : null;

                            // console.log('[FP RENDER] fpData found:', fpData ? Object.keys(fpData).length : 'NULL', 'for TS:', ts);

                            // Iterate FP Data
                            if (fpData) {
                                let maxVol = 1;
                                for (let p in fpData) {
                                    maxVol = Math.max(maxVol, fpData[p].buy, fpData[p].sell);
                                }

                                for (let priceStr in fpData) {
                                    const price = parseFloat(priceStr);
                                    const vol = fpData[priceStr];
                                    const y = api.coord([0, price])[1];
                                    const rowHeight = 14;

                                    const buyW = (vol.buy / maxVol) * halfWidth;
                                    const sellW = (vol.sell / maxVol) * halfWidth;

                                    if (vol.buy > 0) {
                                        children.push({
                                            type: 'rect',
                                            shape: {
                                                x: x,
                                                y: y - rowHeight / 2,
                                                width: buyW,
                                                height: rowHeight
                                            },
                                            style: { fill: 'rgba(0, 255, 0, 0.4)' }
                                        });
                                    }

                                    if (vol.sell > 0) {
                                        children.push({
                                            type: 'rect',
                                            shape: {
                                                x: x - sellW,
                                                y: y - rowHeight / 2,
                                                width: sellW,
                                                height: rowHeight
                                            },
                                            style: { fill: 'rgba(255, 0, 0, 0.4)' }
                                        });
                                    }

                                    const text = `${vol.buy} x ${vol.sell}`;

                                    children.push({
                                        type: 'text',
                                        x: x,
                                        y: y,
                                        style: {
                                            text: text,
                                            fontSize: 9,
                                            fill: '#333',
                                            textAlign: 'center',
                                            textVerticalAlign: 'middle',
                                            fontFamily: 'monospace',
                                            fontWeight: 'bold'
                                        }
                                    });
                                }
                            }
                            return { type: 'group', children: children };
                        },
                        data: [],
                        z: 10
                    }
                    */
                ]
            };
        };

        const initChart = () => {
            const chartDom = document.getElementById('trading-chart');
            tradingChart = echarts.init(chartDom);
            tradingChart.setOption(getChartOption());
            window.addEventListener('resize', () => tradingChart.resize());
        };

        // Socket IO Handlers
        socket.on('connect', () => {
            document.getElementById('connection-status').innerText = 'Connected';
            document.getElementById('connection-status').className = 'text-sm font-normal text-green-400 ml-2';

            // Auto-subscribe to Live Feed on Connect
            if (INSTRUMENT_KEY) {
                console.log('Subscribing to Live Feed for:', INSTRUMENT_KEY);
                socket.emit('subscribe_to_instrument', { instrument_key: INSTRUMENT_KEY });
            }
        });

        socket.on('disconnect', () => {
            document.getElementById('connection-status').innerText = 'Disconnected';
            document.getElementById('connection-status').className = 'text-sm font-normal text-red-400 ml-2';
        });

        socket.on('footprint_history', (bars) => {
            console.log('[HISTORY] Received', bars.length, 'intraday bars');
            bars.forEach(bar => {
                finalizeBar(bar);
            });
            // Ensure the chart is fully updated/rendered after bulk load
            // finalizeBar calls _renderChart internally, which is efficient enough for valid series
            // But we might want to ensure zoom or latest view?
        });

        socket.on('footprint_update', (bar) => {
            // console.log('[SOCKET] Received footprint_update for TS:', bar.ts);
            updateChartData(bar);
        });

        socket.on('footprint_data', (finalBar) => {
            console.log('[SOCKET] Received footprint_data:', finalBar);
            finalizeBar(finalBar);
        });

        socket.on('replay_error', (data) => {
            console.error('Replay Error:', data.message);
            alert(`Replay Error: ${data.message}`);
            document.getElementById('waiting-message').classList.remove('hidden');
        });

        socket.on('replay_finished', (data) => {
            if (data.reason === 'completed') {
                console.log('All historical data has been replayed.');
            }
        });

        function updateChartData(bar) {
            chartUpdateBuffer = bar;
            if (Date.now() - lastChartUpdate > RENDER_INTERVAL) {
                flushChartBuffer();
            }
        }

        setInterval(() => {
            if (chartUpdateBuffer && Date.now() - lastChartUpdate > RENDER_INTERVAL) {
                flushChartBuffer();
            }
        }, 200);

        function flushChartBuffer() {
            if (!chartUpdateBuffer) return;
            const bar = chartUpdateBuffer;
            lastChartUpdate = Date.now();
            _renderChart(bar);
        }

        function _renderChart(bar) {
            document.getElementById('waiting-message').classList.add('hidden');

            let seriesData = [
                tradingChart.getOption().series[0].data,
                tradingChart.getOption().series[1].data,
                tradingChart.getOption().series[2].data,
                tradingChart.getOption().series[3].data,
                tradingChart.getOption().series[4].data,
                tradingChart.getOption().series[5].data,
                tradingChart.getOption().series[6].data,
                tradingChart.getOption().series[7].data
            ];

            let ts = bar.ts;
            if (ts < 1000000000000) ts *= 1000;

            let xAxisData = tradingChart.getOption().xAxis[0].data || [];
            const existingIndex = xAxisData.indexOf(ts);

            const newPoint = [bar.open, bar.close, bar.low, bar.high];

            let nBuy = bar.buy_volume || 0;
            let bBuy = bar.big_buy_volume || 0;
            let nSell = bar.sell_volume || 0;
            let bSell = bar.big_sell_volume || 0;
            nBuy -= bBuy;

            // Bubbles Positioning Logic
            const tfSelector = document.getElementById('timeframe');
            const currentTF = tfSelector ? parseInt(tfSelector.value) : (window.currentTimeframe || 1);
            const tfMs = currentTF * 60 * 1000;
            const barStart = ts;

            // PERFORMANCE: Bubble rendering disabled for faster chart updates
            let newBubbles = [];
            /* COMMENTED OUT FOR PERFORMANCE
            if (bar.bubbles && bar.bubbles.length > 0) {
                bar.bubbles.forEach(b => {
                    let bts = b.x;
                    if (bts < 1000000000000) bts *= 1000;

                    let progress = (bts - barStart) / tfMs;
                    // progress = Math.max(0.05, Math.min(0.95, progress)); // Remove clamping
                    let xOffset = progress - 0.5; // Map 0..1 to -0.5..0.5 (Full width)
                    const baseIndex = existingIndex >= 0 ? existingIndex : xAxisData.length;
                    const xPos = baseIndex + xOffset;

                    newBubbles.push([xPos, b.y, b.q, b.side]);
                });
            }
            */

            if (!window.footprintCache) window.footprintCache = {};
            window.footprintCache[ts] = bar.footprint;
            if (!window.footprintCache) window.footprintCache = {};
            window.footprintCache[ts] = bar.footprint;
            // console.log('[RENDER CHART] Caching footprint for TS:', ts, 'Keys:', bar.footprint ? Object.keys(bar.footprint).length : 'NULL');

            const footprintItem = {
                value: [existingIndex >= 0 ? existingIndex : xAxisData.length, bar.close],
                raw_ts: ts
            };

            if (existingIndex >= 0) {
                seriesData[0][existingIndex] = newPoint;
                seriesData[2][existingIndex] = nBuy;
                seriesData[3][existingIndex] = bBuy;
                seriesData[4][existingIndex] = nSell;
                seriesData[5][existingIndex] = bSell;
                seriesData[6][existingIndex] = bar.cvd || 0;
                seriesData[7][existingIndex] = footprintItem;

                /* COMMENTED OUT FOR PERFORMANCE
                if (newBubbles.length > 0) {
                    seriesData[1].push(...newBubbles);
                }
                */
            } else {
                // Find the correct insertion index to maintain chronological order
                let insertIndex = xAxisData.length;
                for (let i = 0; i < xAxisData.length; i++) {
                    if (ts < xAxisData[i]) {
                        insertIndex = i;
                        break;
                    }
                }

                // Insert at the correct position
                xAxisData.splice(insertIndex, 0, ts);
                seriesData[0].splice(insertIndex, 0, newPoint);
                seriesData[2].splice(insertIndex, 0, nBuy);
                seriesData[3].splice(insertIndex, 0, bBuy);
                seriesData[4].splice(insertIndex, 0, nSell);
                seriesData[5].splice(insertIndex, 0, bSell);
                seriesData[6].splice(insertIndex, 0, bar.cvd || 0);
                seriesData[7].splice(insertIndex, 0, footprintItem);

                /* COMMENTED OUT FOR PERFORMANCE
                if (newBubbles.length > 0) {
                    seriesData[1].push(...newBubbles);
                }
                */
            }

            tradingChart.setOption({
                xAxis: [
                    { data: xAxisData },
                    { data: xAxisData },
                    { data: xAxisData },
                    { max: xAxisData.length - 0.5 } // Update max for bubble axis
                ],
                series: [
                    { data: seriesData[0] },  // Candlesticks
                    { data: seriesData[1] },  // Bubbles (disabled)
                    { data: seriesData[2] },  // Normal Buy Volume
                    { data: seriesData[3] },  // Big Buy Volume
                    { data: seriesData[4] },  // Normal Sell Volume
                    { data: seriesData[5] }   // Big Sell Volume
                    // CVD and Footprint disabled for performance
                    // { data: seriesData[6] },  // CVD
                    // { data: seriesData[7] }   // Footprint
                ]
            });

            document.getElementById('stats-left').innerText = `Price: ${bar.close.toFixed(2)} | Vol: ${bar.volume}`;
            document.getElementById('stats-right').innerText = new Date(ts).toLocaleTimeString();
        }

        function finalizeBar(bar) {
            _renderChart(bar);
        }

        function startLiveMode() {
            stopReplay();
            console.log("Switching to LIVE Mode...");
            window.footprintCache = {};
            // Optional: reset chart data series?
            // tradingChart.setOption(getChartOption(), true); // Clear

            socket.emit('subscribe_to_instrument', { instrument_key: INSTRUMENT_KEY });
            document.getElementById('waiting-message').classList.remove('hidden');
        }

        function startReplay() {
            if (!socket.connected) {
                alert("Socket not connected! Please wait or refresh.");
                return;
            }
            console.log("Starting Replay...");
            const speed = document.getElementById('replay-speed').value;
            const timeframe = document.getElementById('timeframe').value;
            const startDateStr = document.getElementById('replay-start').value;

            window.currentTimeframe = parseInt(timeframe);

            let startTs = null;
            if (startDateStr) {
                startTs = new Date(startDateStr).getTime() / 1000;
            }

            window.footprintCache = {};
            ohlcData = [];

            tradingChart.setOption(getChartOption(), true);

            console.log(`Emitting replay_market_data for ${INSTRUMENT_KEY} at speed ${speed}, start: ${startTs}, tf: ${timeframe}`);
            socket.emit('replay_market_data', {
                instrument_key: INSTRUMENT_KEY,
                speed: parseInt(speed),
                start_ts: startTs,
                timeframe: parseInt(timeframe)
            });

            document.getElementById('waiting-message').classList.add('hidden');
        }

        function stopReplay() {
            socket.emit('stop_replay');
        }

        initChart();
    </script>
</body>

</html>