<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lightweight Chart - {{ instrument_key }}</title>
    <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>


    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }

        #chart-container {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #main-chart,
        #volume-chart {
            width: 100%;
            /* Set a minimum height for the main chart to ensure it's visible before resize */
            min-height: 400px;
        }

        #main-chart {
            flex-grow: 4;
        }

        #volume-chart {
            flex-grow: 1;
            height: 15vh;
        }

        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }

        .status {
            color: #0ECB81;
        }
    </style>
</head>

<body>
    <div id="stats">
        <div><strong>{{ instrument_key }}</strong></div>
        <div id="price-info">Price: -- | Vol: --</div>
        <div id="time-info">Time: --</div>
        <div class="status" id="connection-status">Connecting...</div>
    </div>

    <div id="chart-container">
        <div id="main-chart"></div>
        <div id="volume-chart"></div>
    </div>

    <script>
        // --- WRAP CODE IN AN IIFE TO PROVIDE FUNCTION SCOPE (Fixes Illegal return) ---
        (function () {
            const INSTRUMENT_KEY = "{{ instrument_key }}";
            const socket = io();

            // --- FIX: Safely access functions and constants from the global object ---
            if (typeof window.LightweightCharts === 'undefined') {
                console.error("Lightweight Charts library failed to load.");
                document.getElementById('connection-status').innerText = 'Chart Error: Library Missing';
                return; // RETURN IS NOW LEGAL inside this IIFE function
            }

            const {
                createChart,
                CrosshairMode,
                LineStyle,
            } = window.LightweightCharts;

            const urlParams = new URLSearchParams(window.location.search);
            // Times need to be converted to Unix timestamps (seconds)
            const entryTs = urlParams.get('entry') ? Math.floor(parseInt(urlParams.get('entry')) / 1000) : null;
            const exitTs = urlParams.get('exit') ? Math.floor(parseInt(urlParams.get('exit')) / 1000) : null;
            const slPrice = parseFloat(urlParams.get('sl'));

            // --- CHART INITIALIZATION ---
            const chartOptions = {
                layout: {
                    background: { color: '#1a1a1a' },
                    textColor: '#888',
                },
                grid: {
                    vertLines: { color: '#333' },
                    horzLines: { color: '#333' },
                },
                timeScale: {
                    timeVisible: true,
                    secondsVisible: false,
                },
                watermark: {
                    visible: true,
                    fontSize: 40,
                    horzAlign: 'center',
                    vertAlign: 'center',
                    color: 'rgba(255, 255, 255, 0.1)',
                    text: INSTRUMENT_KEY,
                },
            };

            // Main Chart (Candles)
            const mainChartElement = document.getElementById('main-chart');
            const mainChart = createChart(mainChartElement, {
                ...chartOptions,
                height: mainChartElement.clientHeight,
                rightPriceScale: { visible: true, borderVisible: false, },
                crosshair: { mode: CrosshairMode.Normal, },
            });

            const candleSeries = mainChart.addCandlestickSeries({
                upColor: '#0ECB81',
                downColor: '#F6465D',
                borderVisible: true,
                wickUpColor: '#0ECB81',
                wickDownColor: '#F6465D',
            });

            // Stop Loss Line (Horizontal Line)
            let slLine = null;
            if (slPrice) {
                slLine = candleSeries.createPriceLine({
                    price: slPrice,
                    color: '#F6465D',
                    lineWidth: 2,
                    lineStyle: LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: 'SL',
                });
            }


            // Volume Chart (Bars)
            const volumeChartElement = document.getElementById('volume-chart');
            const volumeChart = createChart(volumeChartElement, {
                ...chartOptions,
                height: volumeChartElement.clientHeight,
                leftPriceScale: { visible: false, },
                rightPriceScale: { visible: false, },
                timeScale: {
                    ...chartOptions.timeScale,
                    borderVisible: false,
                },
                // Disable interactions on volume chart to prevent conflicts
                handleScroll: false,
                handleScale: false,
            });

            const volumeSeries = volumeChart.addHistogramSeries({ // Using Histogram for colored bars
                color: 'rgba(255, 255, 255, 0.2)',
                priceFormat: {
                    type: 'volume',
                },
                priceScaleId: 'volume',
                scaleMargins: {
                    top: 0.8,
                    bottom: 0,
                }
            });

            // --- LINK THE CHARTS' TIME AXES (Required for Zoom/Scroll Sync) ---
            mainChart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                volumeChart.timeScale().setVisibleRange(timeRange);
            });
            volumeChart.timeScale().subscribeVisibleTimeRangeChange(timeRange => {
                mainChart.timeScale().setVisibleRange(timeRange);
            });


            // --- DATA HANDLERS ---
            let markers = [];

            function addBar(bar) {
                let ts_ms = bar.ts;
                if (ts_ms < 1000000000000) ts_ms *= 1000;
                const timeSec = Math.floor(ts_ms / 1000);

                // 1. Candlestick Data
                const candleItem = {
                    time: timeSec,
                    open: bar.open,
                    high: bar.high,
                    low: bar.low,
                    close: bar.close,
                };

                // 2. Volume Data
                const buyVol = (bar.buy_volume || 0) + (bar.big_buy_volume || 0);
                const sellVol = (bar.sell_volume || 0) + (bar.big_sell_volume || 0);
                const totalVolume = buyVol + sellVol;

                const volumeItem = {
                    time: timeSec,
                    value: totalVolume,
                    color: bar.close >= bar.open ? '#0ECB81' : '#F6465D',
                };

                // 3. Update Markers (Finding the bar where the trade occurred)
                if (entryTs && timeSec === entryTs) {
                    markers.push({
                        time: entryTs,
                        position: 'belowBar',
                        color: '#0ECB81',
                        shape: 'arrowUp',
                        text: 'ENTRY',
                        size: 1.5
                    });
                }
                if (exitTs && timeSec === exitTs) {
                    markers.push({
                        time: exitTs,
                        position: 'aboveBar',
                        color: '#F6465D',
                        shape: 'arrowDown',
                        text: 'EXIT',
                        size: 1.5
                    });
                }
                candleSeries.setMarkers(markers);


                // 4. Update the Series (High-Performance Real-Time Update)
                candleSeries.update(candleItem);
                volumeSeries.update(volumeItem);

                // 5. Scroll to the latest bar
                mainChart.timeScale().scrollToRealTime();

                // 6. Update Stats
                const timeStr = new Date(ts_ms).toLocaleTimeString();
                document.getElementById('price-info').innerText = `Price: ${bar.close.toFixed(2)} | Vol: ${totalVolume}`;
                document.getElementById('time-info').innerText = `Time: ${timeStr}`;
            }

            // --- SOCKET HANDLERS ---

            socket.on('connect', () => {
                document.getElementById('connection-status').innerText = 'Connected';
                document.getElementById('connection-status').style.color = '#0ECB81';
                socket.emit('subscribe_to_instrument', { instrument_key: INSTRUMENT_KEY });
            });

            socket.on('disconnect', () => {
                document.getElementById('connection-status').innerText = 'Disconnected';
                document.getElementById('connection-status').style.color = '#F6465D';
            });

            // INITIAL DATA LOAD
            socket.on('footprint_history', (bars) => {
                console.log('Received history:', bars.length, 'bars');

                const initialCandles = [];
                const initialVolumes = [];
                let historyMarkers = []; // Temporary array for history markers

                bars.forEach(bar => {
                    let ts_ms = bar.ts;
                    if (ts_ms < 1000000000000) ts_ms *= 1000;
                    const timeSec = Math.floor(ts_ms / 1000);

                    // Add marker data if trade happened in this bar
                    if (entryTs && timeSec === entryTs) {
                        historyMarkers.push({
                            time: entryTs,
                            position: 'belowBar',
                            color: '#0ECB81',
                            shape: 'arrowUp',
                            text: 'ENTRY',
                            size: 1.5
                        });
                    }
                    if (exitTs && timeSec === exitTs) {
                        historyMarkers.push({
                            time: exitTs,
                            position: 'aboveBar',
                            color: '#F6465D',
                            shape: 'arrowDown',
                            text: 'EXIT',
                            size: 1.5
                        });
                    }

                    initialCandles.push({
                        time: timeSec,
                        open: bar.open,
                        high: bar.high,
                        low: bar.low,
                        close: bar.close,
                    });

                    const buyVol = (bar.buy_volume || 0) + (bar.big_buy_volume || 0);
                    const sellVol = (bar.sell_volume || 0) + (bar.big_sell_volume || 0);
                    const totalVolume = buyVol + sellVol;

                    initialVolumes.push({
                        time: timeSec,
                        value: totalVolume,
                        color: bar.close >= bar.open ? '#0ECB81' : '#F6465D',
                    });
                });

                markers = historyMarkers; // Update the global markers list

                // Set all data at once
                candleSeries.setData(initialCandles);
                volumeSeries.setData(initialVolumes);

                // Set markers once after history load
                candleSeries.setMarkers(markers);

                // Fit all data to view
                mainChart.timeScale().fitContent();
            });

            // REAL-TIME UPDATES
            socket.on('footprint_update', (bar) => {
                addBar(bar);
            });

            socket.on('footprint_data', (bar) => {
                addBar(bar);
            });

            // --- RESIZE HANDLER ---
            window.addEventListener('resize', () => {
                const mainWidth = mainChartElement.clientWidth;
                const mainHeight = mainChartElement.clientHeight;
                const volumeWidth = volumeChartElement.clientWidth;
                const volumeHeight = volumeChartElement.clientHeight;

                mainChart.resize(mainWidth, mainHeight);
                volumeChart.resize(volumeWidth, volumeHeight);
            });
        })(); // Self-executing function ends here
    </script>
</body>

</html>